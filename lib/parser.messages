prog: LCURLY RCURLY WITH
##
## Ends in an error in state: 309.
##
## prog -> LCURLY RCURLY . EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY RCURLY
##

Missing top level element

prog: LCURLY CHAR RCURLY WITH
##
## Ends in an error in state: 343.
##
## prog -> LCURLY toplevels RCURLY . EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY toplevels RCURLY
##

Unexpected trailing token after a completed program

prog: LCURLY TYPE LCURLY WITH
##
## Ends in an error in state: 3.
##
## block_aliases -> LCURLY . aliases RCURLY [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing type definitions

prog: LCURLY TYPE LCURLY IDCTOR SEMI
##
## Ends in an error in state: 4.
##
## alias -> IDCTOR . list(IDVAR) SET annot [ SEMI RCURLY ]
## alias -> IDCTOR . list(IDVAR) SET nonempty_list(ctor) [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR IDVAR SEMI
##
## Ends in an error in state: 5.
##
## list(IDVAR) -> IDVAR . list(IDVAR) [ SET ]
##
## The known suffix of the stack is as follows:
## IDVAR
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR SET SEMI
##
## Ends in an error in state: 8.
##
## alias -> IDCTOR list(IDVAR) SET . annot [ SEMI RCURLY ]
## alias -> IDCTOR list(IDVAR) SET . nonempty_list(ctor) [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(IDVAR) SET
##

Missing type expression

prog: LCURLY EXTERN LCURLY WITH
##
## Ends in an error in state: 328.
##
## block_externs -> LCURLY . externs RCURLY [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing external definitions

prog: LCURLY EXTERN LCURLY IDVAR WITH
##
## Ends in an error in state: 329.
##
## externs -> IDVAR . COLON annot SET STR SEMI externs [ RCURLY ]
## externs -> IDVAR . COLON annot SET STR option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR
##

Incomplete external definition

prog: LCURLY EXTERN LCURLY IDVAR COLON WITH
##
## Ends in an error in state: 330.
##
## externs -> IDVAR COLON . annot SET STR SEMI externs [ RCURLY ]
## externs -> IDVAR COLON . annot SET STR option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON
##

Missing explicit type annotation

prog: LCURLY EXTERN LCURLY IDVAR COLON IDVAR WITH
##
## Ends in an error in state: 331.
##
## externs -> IDVAR COLON annot . SET STR SEMI externs [ RCURLY ]
## externs -> IDVAR COLON annot . SET STR option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON annot
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production annot -> annot2
##

Missing '='

prog: LCURLY EXTERN LCURLY IDVAR COLON IDVAR SET WITH
##
## Ends in an error in state: 332.
##
## externs -> IDVAR COLON annot SET . STR SEMI externs [ RCURLY ]
## externs -> IDVAR COLON annot SET . STR option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON annot SET
##

Missing external name of external definition

prog: LCURLY DEF LCURLY WITH
##
## Ends in an error in state: 143.
##
## block_vbinds -> LCURLY . vbinds RCURLY [ SEMI RCURLY IN ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing value definitions

prog: LCURLY DEF LCURLY IDVAR WITH
##
## Ends in an error in state: 160.
##
## vbind -> IDVAR . COLON cnsted_type [ SEMI RCURLY ]
## vbind -> IDVAR . list(pat4) SET expr [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR
##

Incomplete value definition

prog: LCURLY DEF LCURLY IDVAR IDVAR WITH
##
## Ends in an error in state: 183.
##
## list(pat4) -> pat4 . list(pat4) [ SET ]
##
## The known suffix of the stack is as follows:
## pat4
##

Incomplete value definition

prog: LCURLY DEF LCURLY IDVAR COLON WITH
##
## Ends in an error in state: 161.
##
## vbind -> IDVAR COLON . cnsted_type [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON
##

Missing explicit type annotation

prog: LCURLY DEF LCURLY IDVAR SET WITH
##
## Ends in an error in state: 186.
##
## vbind -> IDVAR list(pat4) SET . expr [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR list(pat4) SET
##

Missing initializer for value definition

prog: LCURLY DEF LCURLY LPAREN WITH
##
## Ends in an error in state: 144.
##
## vop_name -> LPAREN . BAR RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . NOT RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . NEG RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VPRE RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VMUL RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VADD RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VRCN RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VAPP RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
## vop_name -> LPAREN . OP_VCMP RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Missing operator name

prog: LCURLY DEF LCURLY LPAREN BAR WITH
##
## Ends in an error in state: 158.
##
## vop_name -> LPAREN BAR . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN BAR
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN NOT WITH
##
## Ends in an error in state: 154.
##
## vop_name -> LPAREN NOT . RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
##
## The known suffix of the stack is as follows:
## LPAREN NOT
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN NEG WITH
##
## Ends in an error in state: 156.
##
## vop_name -> LPAREN NEG . RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
##
## The known suffix of the stack is as follows:
## LPAREN NEG
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VPRE WITH
##
## Ends in an error in state: 145.
##
## vop_name -> LPAREN OP_VPRE . RPAREN [ UNDERSCORE STR SET REF LSQUARE LPAREN INT IDVAR IDCTOR COLON CHAR ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VPRE
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VMUL WITH
##
## Ends in an error in state: 146.
##
## vop_name -> LPAREN OP_VMUL . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VMUL
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VADD WITH
##
## Ends in an error in state: 152.
##
## vop_name -> LPAREN OP_VADD . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VADD
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VRCN WITH
##
## Ends in an error in state: 137.
##
## vop_name -> LPAREN OP_VRCN . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VRCN
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VAPP WITH
##
## Ends in an error in state: 150.
##
## vop_name -> LPAREN OP_VAPP . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VAPP
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VCMP WITH
##
## Ends in an error in state: 148.
##
## vop_name -> LPAREN OP_VCMP . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VCMP
##

Missing ')'

prog: LCURLY DEF LCURLY LPAREN OP_VADD RPAREN WITH
##
## Ends in an error in state: 261.
##
## vbind -> vop_name . COLON cnsted_type [ SEMI RCURLY ]
## vbind -> vop_name . list(pat4) SET expr [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## vop_name
##

Incomplete operator definition

prog: LCURLY DEF LCURLY LPAREN OP_VADD RPAREN COLON WITH
##
## Ends in an error in state: 262.
##
## vbind -> vop_name COLON . cnsted_type [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## vop_name COLON
##

Missing explicit type annotation

prog: LCURLY DEF LCURLY LPAREN OP_VADD RPAREN SET WITH
##
## Ends in an error in state: 265.
##
## vbind -> vop_name list(pat4) SET . expr [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## vop_name list(pat4) SET
##

Missing initializer for operator definition

repl_expr: LCURLY WITH
##
## Ends in an error in state: 358.
##
## repl_expr -> LCURLY . expr RCURLY EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing expression

repl_annot: LCURLY WITH
##
## Ends in an error in state: 352.
##
## repl_annot -> LCURLY . annot RCURLY EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing type expression

prog: LCURLY IF SEMI
##
## Ends in an error in state: 190.
##
## expr4 -> IF . expr option(SEMI) THEN expr option(SEMI) ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF
##

Missing if condition

prog: LCURLY IF IDVAR WITH
##
## Ends in an error in state: 246.
##
## expr4 -> IF expr . option(SEMI) THEN expr option(SEMI) ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Missing 'then'

prog: LCURLY IF CHAR SEMI WITH
##
## Ends in an error in state: 248.
##
## expr4 -> IF expr option(SEMI) . THEN expr option(SEMI) ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr option(SEMI)
##

Missing 'then'

prog: LCURLY IF IDVAR THEN SEMI
##
## Ends in an error in state: 249.
##
## expr4 -> IF expr option(SEMI) THEN . expr option(SEMI) ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr option(SEMI) THEN
##

Missing then clause

prog: LCURLY IF IDVAR THEN IDVAR WITH
##
## Ends in an error in state: 250.
##
## expr4 -> IF expr option(SEMI) THEN expr . option(SEMI) ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr option(SEMI) THEN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Missing 'else'

prog: LCURLY IF CHAR THEN CHAR SEMI WITH
##
## Ends in an error in state: 251.
##
## expr4 -> IF expr option(SEMI) THEN expr option(SEMI) . ELSE expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr option(SEMI) THEN expr option(SEMI)
##

Missing 'else'

prog: LCURLY IF IDVAR THEN IDVAR ELSE SEMI
##
## Ends in an error in state: 252.
##
## expr4 -> IF expr option(SEMI) THEN expr option(SEMI) ELSE . expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## IF expr option(SEMI) THEN expr option(SEMI) ELSE
##

Missing else clause

prog: LCURLY LET LCURLY IDVAR SET INT RCURLY WITH
##
## Ends in an error in state: 276.
##
## expr4 -> LET block_vbinds . IN expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LET block_vbinds
##

Missing 'in'

prog: LCURLY LET LCURLY IDVAR SET INT RCURLY IN WITH
##
## Ends in an error in state: 277.
##
## expr4 -> LET block_vbinds IN . expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LET block_vbinds IN
##

Missing scoped expression

prog: LCURLY LET REC LCURLY IDVAR SET INT RCURLY WITH
##
## Ends in an error in state: 273.
##
## expr4 -> LET REC block_vbinds . IN expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LET REC block_vbinds
##

Missing 'in'

prog: LCURLY LET REC LCURLY IDVAR SET INT RCURLY IN WITH
##
## Ends in an error in state: 274.
##
## expr4 -> LET REC block_vbinds IN . expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LET REC block_vbinds IN
##

Missing scoped expression

prog: LCURLY SLASH WITH
##
## Ends in an error in state: 64.
##
## expr4 -> SLASH . nonempty_list(pat4) ARROW expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr4 -> SLASH . MATCH block_cases [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## SLASH
##

Missing lambda arguments or 'match'

prog: LCURLY SLASH IDVAR WITH
##
## Ends in an error in state: 84.
##
## nonempty_list(pat4) -> pat4 . [ RSQUARE RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
## nonempty_list(pat4) -> pat4 . nonempty_list(pat4) [ RSQUARE RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat4
##

Incomplete lambda expression

prog: LCURLY SLASH IDVAR ARROW WITH
##
## Ends in an error in state: 307.
##
## expr4 -> SLASH nonempty_list(pat4) ARROW . expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## SLASH nonempty_list(pat4) ARROW
##

Missing lambda body

prog: LCURLY MATCH WITH
##
## Ends in an error in state: 132.
##
## expr4 -> MATCH . expr WITH block_cases [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## MATCH
##

Missing match scrutinee

prog: LCURLY MATCH IDVAR SEMI
##
## Ends in an error in state: 296.
##
## expr4 -> MATCH expr . WITH block_cases [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## MATCH expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Missing 'with'

prog: LCURLY MATCH IDVAR WITH LCURLY SEMI
##
## Ends in an error in state: 69.
##
## block_cases -> LCURLY . cases RCURLY [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Missing match pattern

prog: LCURLY MATCH IDVAR WITH LCURLY IDVAR SEMI
##
## Ends in an error in state: 125.
##
## cases -> pat . ARROW expr SEMI cases [ RCURLY ]
## cases -> pat . ARROW expr option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## pat
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 96, spurious reduction of production pat2_add -> pat2_mul
## In state 100, spurious reduction of production pat2_rcn -> pat2_add
## In state 93, spurious reduction of production pat2_app -> pat2_rcn
## In state 109, spurious reduction of production pat2_cmp -> pat2_app
## In state 105, spurious reduction of production pat2 -> pat2_cmp
## In state 111, spurious reduction of production pat -> pat2
##

Missing '->'

prog: LCURLY MATCH IDVAR WITH LCURLY IDVAR ARROW SEMI
##
## Ends in an error in state: 126.
##
## cases -> pat ARROW . expr SEMI cases [ RCURLY ]
## cases -> pat ARROW . expr option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## pat ARROW
##

Missing pattern action

prog: LCURLY INT COLON SEMI
##
## Ends in an error in state: 244.
##
## expr -> expr2 COLON . annot [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2 COLON
##

Missing type annotation

prog: LCURLY SLASH MATCH LCURLY INT COLON SEMI
##
## Ends in an error in state: 112.
##
## pat -> pat2 COLON . annot [ RSQUARE RPAREN COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## pat2 COLON
##

Missing type annotation

prog: LCURLY INT COLON IDVAR ARROW SEMI
##
## Ends in an error in state: 24.
##
## annot -> annot2 ARROW . annot [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## annot2 ARROW
##

Missing function return type

prog: LCURLY INT SET SEMI
##
## Ends in an error in state: 230.
##
## expr2 -> expr2_or SET . expr2 [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_or SET
##

Missing rhs of binary operator

prog: LCURLY INT OR SEMI
##
## Ends in an error in state: 241.
##
## expr2_or -> expr2_or OR . expr2_and [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_or OR
##

Missing rhs of binary operator

prog: LCURLY INT AND SEMI
##
## Ends in an error in state: 238.
##
## expr2_and -> expr2_and AND . expr2_cmp [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_and AND
##

Missing rhs of binary operator

prog: LCURLY INT OP_VCMP SEMI
##
## Ends in an error in state: 232.
##
## expr2_cmp -> expr2_cmp OP_VCMP . expr2_app [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_cmp OP_VCMP
##

Missing rhs of binary operator

prog: LCURLY INT OP_DCMP SEMI
##
## Ends in an error in state: 234.
##
## expr2_cmp -> expr2_cmp OP_DCMP . expr2_app [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_cmp OP_DCMP
##

Missing rhs of binary operator

prog: LCURLY INT OP_VAPP SEMI
##
## Ends in an error in state: 204.
##
## expr2_app -> expr2_rcn OP_VAPP . expr2_app [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_rcn OP_VAPP
##

Missing rhs of binary operator

prog: LCURLY INT OP_DAPP SEMI
##
## Ends in an error in state: 227.
##
## expr2_app -> expr2_rcn OP_DAPP . expr2_app [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_rcn OP_DAPP
##

Missing rhs of binary operator

prog: LCURLY INT OP_VRCN SEMI
##
## Ends in an error in state: 215.
##
## expr2_rcn -> expr2_add OP_VRCN . expr2_rcn [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add OP_VRCN
##

Missing rhs of binary operator

prog: LCURLY INT OP_DRCN SEMI
##
## Ends in an error in state: 219.
##
## expr2_rcn -> expr2_add OP_DRCN . expr2_rcn [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add OP_DRCN
##

Missing rhs of binary operator

prog: LCURLY INT BAR SEMI
##
## Ends in an error in state: 225.
##
## expr2_add -> expr2_add BAR . expr2_mul [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add BAR
##

Missing rhs of binary operator

prog: LCURLY INT NEG WITH
##
## Ends in an error in state: 223.
##
## expr2_add -> expr2_add NEG . expr2_mul [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add NEG
##

Missing rhs of binary operator

prog: LCURLY INT OP_VADD SEMI
##
## Ends in an error in state: 217.
##
## expr2_add -> expr2_add OP_VADD . expr2_mul [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add OP_VADD
##

Missing rhs of binary operator

prog: LCURLY INT OP_DADD SEMI
##
## Ends in an error in state: 221.
##
## expr2_add -> expr2_add OP_DADD . expr2_mul [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_add OP_DADD
##

Missing rhs of binary operator

prog: LCURLY INT OP_VMUL SEMI
##
## Ends in an error in state: 207.
##
## expr2_mul -> expr2_mul OP_VMUL . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_mul OP_VMUL
##

Missing rhs of binary operator

prog: LCURLY INT OP_DMUL SEMI
##
## Ends in an error in state: 211.
##
## expr2_mul -> expr2_mul OP_DMUL . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## expr2_mul OP_DMUL
##

Missing rhs of binary operator

prog: LCURLY OP_VPRE SEMI
##
## Ends in an error in state: 128.
##
## expr2_prefix -> OP_VPRE . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## OP_VPRE
##

Missing rhs of prefix operator

prog: LCURLY OP_DPRE SEMI
##
## Ends in an error in state: 129.
##
## expr2_prefix -> OP_DPRE . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## OP_DPRE
##

Missing rhs of prefix operator

prog: LCURLY NOT SEMI
##
## Ends in an error in state: 130.
##
## expr2_prefix -> NOT . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

Missing rhs of prefix operator

prog: LCURLY NEG SEMI
##
## Ends in an error in state: 131.
##
## expr2_prefix -> NEG . expr2_prefix [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## NEG
##

Missing rhs of prefix operator

prog: LCURLY LPAREN OP_VPRE SEMI
##
## Ends in an error in state: 139.
##
## expr2_prefix -> OP_VPRE . expr2_prefix [ SET RPAREN OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG COMMA COLON BAR AND ]
## vop_name -> LPAREN OP_VPRE . RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_VPRE
##

Missing rhs of prefix operator

prog: LCURLY LPAREN OP_DPRE SEMI
##
## Ends in an error in state: 280.
##
## dop_name -> LPAREN OP_DPRE . RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr2_prefix -> OP_DPRE . expr2_prefix [ SET RPAREN OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG COMMA COLON BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DPRE
##

Missing rhs of prefix operator

prog: LCURLY LPAREN NOT SEMI
##
## Ends in an error in state: 282.
##
## expr2_prefix -> NOT . expr2_prefix [ SET RPAREN OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG COMMA COLON BAR AND ]
## vop_name -> LPAREN NOT . RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN NOT
##

Missing rhs of prefix operator

prog: LCURLY LPAREN NEG SEMI
##
## Ends in an error in state: 284.
##
## expr2_prefix -> NEG . expr2_prefix [ SET RPAREN OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG COMMA COLON BAR AND ]
## vop_name -> LPAREN NEG . RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN NEG
##

Missing rhs of prefix operator

prog: LCURLY MATCH IDVAR WITH LCURLY INT BAR SEMI
##
## Ends in an error in state: 108.
##
## pat2 -> pat2_cmp BAR . pat2 [ RSQUARE RPAREN COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_cmp BAR
##

Missing alternate pattern

prog: LCURLY MATCH IDVAR WITH LCURLY INT OP_DCMP SEMI
##
## Ends in an error in state: 106.
##
## pat2_cmp -> pat2_cmp OP_DCMP . pat2_app [ RSQUARE RPAREN OP_DCMP COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_cmp OP_DCMP
##

Missing rhs of binary operator

prog: LCURLY MATCH IDVAR WITH LCURLY INT OP_DAPP SEMI
##
## Ends in an error in state: 94.
##
## pat2_app -> pat2_rcn OP_DAPP . pat2_app [ RSQUARE RPAREN OP_DCMP COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_rcn OP_DAPP
##

Missing rhs of binary operator

prog: LCURLY MATCH IDVAR WITH LCURLY INT OP_DRCN SEMI
##
## Ends in an error in state: 101.
##
## pat2_rcn -> pat2_add OP_DRCN . pat2_rcn [ RSQUARE RPAREN OP_DCMP OP_DAPP COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_add OP_DRCN
##

Missing rhs of binary operator

prog: LCURLY MATCH IDVAR WITH LCURLY INT OP_DADD SEMI
##
## Ends in an error in state: 103.
##
## pat2_add -> pat2_add OP_DADD . pat2_mul [ RSQUARE RPAREN OP_DRCN OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_add OP_DADD
##

Missing rhs of binary operator

prog: LCURLY MATCH IDVAR WITH LCURLY INT OP_DMUL SEMI
##
## Ends in an error in state: 97.
##
## pat2_mul -> pat2_mul OP_DMUL . pat2_prefix [ RSQUARE RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat2_mul OP_DMUL
##

Missing rhs of binary operator

prog: LCURLY MATCH IDVAR WITH LCURLY NEG SEMI
##
## Ends in an error in state: 74.
##
## pat2_prefix -> NEG . INT [ RSQUARE RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## NEG
##

Missing numeric literal

prog: LCURLY MATCH IDVAR WITH LCURLY OP_DPRE SEMI
##
## Ends in an error in state: 73.
##
## pat2_prefix -> OP_DPRE . pat2_prefix [ RSQUARE RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ARROW ]
##
## The known suffix of the stack is as follows:
## OP_DPRE
##

Missing rhs of prefix operator

prog: LCURLY MATCH IDVAR WITH LCURLY LPAREN OP_DPRE SEMI
##
## Ends in an error in state: 78.
##
## dop_name -> LPAREN OP_DPRE . RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## pat2_prefix -> OP_DPRE . pat2_prefix [ RPAREN OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD COMMA COLON BAR ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DPRE
##

Missing rhs of prefix operator

prog: LCURLY LSQUARE SEMI
##
## Ends in an error in state: 133.
##
## expr4 -> LSQUARE . RSQUARE [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr4 -> LSQUARE . list_expr(RSQUARE) RSQUARE [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LSQUARE
##

Incomplete list

prog: LCURLY LSQUARE IDVAR SEMI
##
## Ends in an error in state: 293.
##
## list_expr(RSQUARE) -> expr . COMMA list_expr(RSQUARE) [ RSQUARE ]
## list_expr(RSQUARE) -> expr . [ RSQUARE ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Incomplete list

prog: LCURLY LSQUARE IDVAR COMMA SEMI
##
## Ends in an error in state: 294.
##
## list_expr(RSQUARE) -> expr COMMA . list_expr(RSQUARE) [ RSQUARE ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Missing another list element

prog: LCURLY MATCH IDVAR WITH LCURLY LSQUARE SEMI
##
## Ends in an error in state: 71.
##
## pat4 -> LSQUARE . RSQUARE [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## pat4 -> LSQUARE . list_pat(RSQUARE) RSQUARE [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
##
## The known suffix of the stack is as follows:
## LSQUARE
##

Incomplete list pattern

prog: LCURLY MATCH IDVAR WITH LCURLY LSQUARE IDVAR SEMI
##
## Ends in an error in state: 119.
##
## list_pat(RSQUARE) -> pat . COMMA list_pat(RSQUARE) [ RSQUARE ]
## list_pat(RSQUARE) -> pat . [ RSQUARE ]
##
## The known suffix of the stack is as follows:
## pat
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 96, spurious reduction of production pat2_add -> pat2_mul
## In state 100, spurious reduction of production pat2_rcn -> pat2_add
## In state 93, spurious reduction of production pat2_app -> pat2_rcn
## In state 109, spurious reduction of production pat2_cmp -> pat2_app
## In state 105, spurious reduction of production pat2 -> pat2_cmp
## In state 111, spurious reduction of production pat -> pat2
##

Incomplete list pattern

prog: LCURLY MATCH IDVAR WITH LCURLY LSQUARE IDVAR COMMA SEMI
##
## Ends in an error in state: 120.
##
## list_pat(RSQUARE) -> pat COMMA . list_pat(RSQUARE) [ RSQUARE ]
##
## The known suffix of the stack is as follows:
## pat COMMA
##

Missing another list element

prog: LCURLY LPAREN SEMI
##
## Ends in an error in state: 135.
##
## dop_name -> LPAREN . OP_DPRE RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## dop_name -> LPAREN . OP_DMUL RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## dop_name -> LPAREN . OP_DADD RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## dop_name -> LPAREN . OP_DRCN RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## dop_name -> LPAREN . OP_DAPP RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## dop_name -> LPAREN . OP_DCMP RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr4 -> LPAREN . RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr4 -> LPAREN . list_expr(RPAREN) RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . BAR RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . NOT RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . NEG RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VPRE RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VMUL RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VADD RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VRCN RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VAPP RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## vop_name -> LPAREN . OP_VCMP RPAREN [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Incomplete parenthesized expression

prog: LCURLY LPAREN IDVAR SEMI
##
## Ends in an error in state: 288.
##
## list_expr(RPAREN) -> expr . COMMA list_expr(RPAREN) [ RPAREN ]
## list_expr(RPAREN) -> expr . [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Incomplete parenthesized expression

prog: LCURLY LPAREN IDVAR COMMA SEMI
##
## Ends in an error in state: 289.
##
## list_expr(RPAREN) -> expr COMMA . list_expr(RPAREN) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Missing another tuple element

prog: LCURLY MATCH IDVAR WITH LCURLY LPAREN SEMI
##
## Ends in an error in state: 76.
##
## dop_name -> LPAREN . OP_DPRE RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## dop_name -> LPAREN . OP_DMUL RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## dop_name -> LPAREN . OP_DADD RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## dop_name -> LPAREN . OP_DRCN RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## dop_name -> LPAREN . OP_DAPP RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## dop_name -> LPAREN . OP_DCMP RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## pat4 -> LPAREN . RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
## pat4 -> LPAREN . list_pat(RPAREN) RPAREN [ UNDERSCORE STR SET RSQUARE RPAREN REF OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD LSQUARE LPAREN INT IDVAR IDCTOR COMMA COLON CHAR BAR ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Incomplete parenthesized pattern

prog: LCURLY MATCH IDVAR WITH LCURLY LPAREN IDVAR SEMI
##
## Ends in an error in state: 114.
##
## list_pat(RPAREN) -> pat . COMMA list_pat(RPAREN) [ RPAREN ]
## list_pat(RPAREN) -> pat . [ RPAREN ]
##
## The known suffix of the stack is as follows:
## pat
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 96, spurious reduction of production pat2_add -> pat2_mul
## In state 100, spurious reduction of production pat2_rcn -> pat2_add
## In state 93, spurious reduction of production pat2_app -> pat2_rcn
## In state 109, spurious reduction of production pat2_cmp -> pat2_app
## In state 105, spurious reduction of production pat2 -> pat2_cmp
## In state 111, spurious reduction of production pat -> pat2
##

Incomplete parenthesized pattern

prog: LCURLY MATCH IDVAR WITH LCURLY LPAREN IDVAR COMMA SEMI
##
## Ends in an error in state: 115.
##
## list_pat(RPAREN) -> pat COMMA . list_pat(RPAREN) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## pat COMMA
##

Missing another tuple element

repl_annot: LCURLY LPAREN SEMI
##
## Ends in an error in state: 13.
##
## annot3_no_ctor -> LPAREN . ARROW RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
## annot3_no_ctor -> LPAREN . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
## annot3_no_ctor -> LPAREN . list_annot RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Incomplete parenthesized type

repl_annot: LCURLY LPAREN ARROW SEMI
##
## Ends in an error in state: 17.
##
## annot3_no_ctor -> LPAREN ARROW . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN ARROW
##

Missing ')'

repl_annot: LCURLY LPAREN IDVAR SEMI
##
## Ends in an error in state: 27.
##
## list_annot -> annot . COMMA list_annot [ RPAREN ]
## list_annot -> annot . [ RPAREN ]
##
## The known suffix of the stack is as follows:
## annot
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production annot -> annot2
##

Incomplete parenthesized type

repl_annot: LCURLY LPAREN IDVAR COMMA SEMI
##
## Ends in an error in state: 28.
##
## list_annot -> annot COMMA . list_annot [ RPAREN ]
##
## The known suffix of the stack is as follows:
## annot COMMA
##

Missing another tuple element

repl_annot: LCURLY LSQUARE SEMI
##
## Ends in an error in state: 11.
##
## annot3_no_ctor -> LSQUARE . RSQUARE [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
## annot3_no_ctor -> LSQUARE . annot RSQUARE [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LSQUARE
##

Incomplete list type

repl_annot: LCURLY LSQUARE IDVAR SEMI
##
## Ends in an error in state: 30.
##
## annot3_no_ctor -> LSQUARE annot . RSQUARE [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IMPLIES IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LSQUARE annot
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production annot -> annot2
##

Missing ']'

prog: LCURLY EOF
##
## Ends in an error in state: 1.
##
## prog -> LCURLY . toplevels RCURLY EOF [ # ]
## prog -> LCURLY . RCURLY EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Incomplete program

prog: LCURLY IDVAR SEMI EOF
##
## Ends in an error in state: 346.
##
## option(SEMI) -> SEMI . [ RCURLY ]
## toplevels -> toplevel SEMI . toplevels [ RCURLY ]
##
## The known suffix of the stack is as follows:
## toplevel SEMI
##

Incomplete program

prog: LCURLY LCURLY SEMI
##
## Ends in an error in state: 187.
##
## expr4 -> LCURLY . RCURLY [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
## expr4 -> LCURLY . exprs RCURLY [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## LCURLY
##

Incomplete sequential expression

prog: LCURLY LCURLY IDVAR DEF
##
## Ends in an error in state: 256.
##
## exprs -> expr . SEMI exprs [ RCURLY ]
## exprs -> expr . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Incomplete sequential expression

prog: LCURLY LCURLY IDVAR SEMI DEF
##
## Ends in an error in state: 257.
##
## exprs -> expr SEMI . exprs [ RCURLY ]
## option(SEMI) -> SEMI . [ RCURLY ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Incomplete sequential expression

prog: LCURLY MATCH IDVAR WITH LCURLY IDVAR ARROW IDVAR DEF
##
## Ends in an error in state: 299.
##
## cases -> pat ARROW expr . SEMI cases [ RCURLY ]
## cases -> pat ARROW expr . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## pat ARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Incomplete match pattern

prog: LCURLY TYPE LCURLY IDCTOR SET IDCTOR WITH
##
## Ends in an error in state: 58.
##
## aliases -> alias . SEMI aliases [ RCURLY ]
## aliases -> alias . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production annot -> annot2
## In state 55, spurious reduction of production alias -> IDCTOR list(IDVAR) SET annot
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR SET IDCTOR SEMI WITH
##
## Ends in an error in state: 59.
##
## aliases -> alias SEMI . aliases [ RCURLY ]
## option(SEMI) -> SEMI . [ RCURLY ]
##
## The known suffix of the stack is as follows:
## alias SEMI
##

Incomplete type definition

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR AND
##
## Ends in an error in state: 162.
##
## cnsted_type -> IDCTOR . list(annot3) IMPLIES annot [ SEMI RCURLY ]
## cnsted_type -> IDCTOR . list(annot3) COMMA cnsted_type_tail [ SEMI RCURLY ]
## cnsted_type -> IDCTOR . list(annot3) ARROW annot [ SEMI RCURLY ]
## cnsted_type -> IDCTOR . list(annot3) [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR
##

Incomplete value definition

prog: LCURLY DEF LCURLY IDVAR SET CHAR SEMI WITH
##
## Ends in an error in state: 270.
##
## option(SEMI) -> SEMI . [ RCURLY ]
## vbinds -> vbind SEMI . vbinds [ RCURLY ]
##
## The known suffix of the stack is as follows:
## vbind SEMI
##

Incomplete value definition

prog: LCURLY SLASH MATCH LCURLY CHAR ARROW CHAR SEMI WITH
##
## Ends in an error in state: 300.
##
## cases -> pat ARROW expr SEMI . cases [ RCURLY ]
## option(SEMI) -> SEMI . [ RCURLY ]
##
## The known suffix of the stack is as follows:
## pat ARROW expr SEMI
##

Incomplete match patterns

prog: LCURLY SLASH CHAR RSQUARE
##
## Ends in an error in state: 306.
##
## expr4 -> SLASH nonempty_list(pat4) . ARROW expr [ WITH THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR AND ]
##
## The known suffix of the stack is as follows:
## SLASH nonempty_list(pat4)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production nonempty_list(pat4) -> pat4
##

Incomplete lambda expression

prog: LCURLY EXTERN LCURLY IDVAR COLON IDCTOR SET STR WITH
##
## Ends in an error in state: 333.
##
## externs -> IDVAR COLON annot SET STR . SEMI externs [ RCURLY ]
## externs -> IDVAR COLON annot SET STR . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON annot SET STR
##

Incomplete external definition

prog: LCURLY EXTERN LCURLY IDVAR COLON IDCTOR SET STR SEMI WITH
##
## Ends in an error in state: 334.
##
## externs -> IDVAR COLON annot SET STR SEMI . externs [ RCURLY ]
## option(SEMI) -> SEMI . [ RCURLY ]
##
## The known suffix of the stack is as follows:
## IDVAR COLON annot SET STR SEMI
##

Incomplete external definition

prog: LCURLY CHAR UNDERSCORE
##
## Ends in an error in state: 345.
##
## toplevels -> toplevel . SEMI toplevels [ RCURLY ]
## toplevels -> toplevel . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## toplevel
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
## In state 348, spurious reduction of production toplevel -> expr
##

Unexpected trailing token after a completed top level element

repl_annot: WITH
##
## Ends in an error in state: 351.
##
## repl_annot' -> . repl_annot [ # ]
##
## The known suffix of the stack is as follows:
##
##

Missing type expression

repl_annot: LCURLY IDCTOR WITH
##
## Ends in an error in state: 353.
##
## repl_annot -> LCURLY annot . RCURLY EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY annot
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production annot -> annot2
##

Unexpected trailing token after a completed type expression

repl_expr: WITH
##
## Ends in an error in state: 357.
##
## repl_expr' -> . repl_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Missing expression

repl_expr: LCURLY CHAR WITH
##
## Ends in an error in state: 359.
##
## repl_expr -> LCURLY expr . RCURLY EOF [ # ]
##
## The known suffix of the stack is as follows:
## LCURLY expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 200, spurious reduction of production expr3 -> expr4
## In state 202, spurious reduction of production expr2_prefix -> expr3
## In state 205, spurious reduction of production expr2_mul -> expr2_prefix
## In state 206, spurious reduction of production expr2_add -> expr2_mul
## In state 214, spurious reduction of production expr2_rcn -> expr2_add
## In state 203, spurious reduction of production expr2_app -> expr2_rcn
## In state 236, spurious reduction of production expr2_cmp -> expr2_app
## In state 231, spurious reduction of production expr2_and -> expr2_cmp
## In state 237, spurious reduction of production expr2_or -> expr2_and
## In state 229, spurious reduction of production expr2 -> expr2_or
## In state 243, spurious reduction of production expr -> expr2
##

Unexpected trailing token after a completed expression

prog: LCURLY TYPE LCURLY IDCTOR SET BAR WITH
##
## Ends in an error in state: 32.
##
## ctor -> BAR . IDCTOR list(annot3) [ SEMI RCURLY BAR ]
## ctor -> BAR . dop_name list(annot3) [ SEMI RCURLY BAR ]
##
## The known suffix of the stack is as follows:
## BAR
##

Missing data constructor

prog: LCURLY TYPE LCURLY IDCTOR SET BAR LPAREN WITH
##
## Ends in an error in state: 33.
##
## dop_name -> LPAREN . OP_DPRE RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
## dop_name -> LPAREN . OP_DMUL RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
## dop_name -> LPAREN . OP_DADD RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
## dop_name -> LPAREN . OP_DRCN RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
## dop_name -> LPAREN . OP_DAPP RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
## dop_name -> LPAREN . OP_DCMP RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Missing data constructor operator

prog: LCURLY LPAREN OP_DRCN WITH
##
## Ends in an error in state: 34.
##
## dop_name -> LPAREN OP_DRCN . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DRCN
##

Missing ')'

prog: LCURLY TYPE LCURLY IDCTOR SET BAR LPAREN OP_DPRE WITH
##
## Ends in an error in state: 36.
##
## dop_name -> LPAREN OP_DPRE . RPAREN [ UNDERSCORE SEMI REF RCURLY LSQUARE LPAREN IDVAR IDCTOR BAR ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DPRE
##

Missing ')'

prog: LCURLY LPAREN OP_DMUL WITH
##
## Ends in an error in state: 38.
##
## dop_name -> LPAREN OP_DMUL . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DMUL
##

Missing ')'

prog: LCURLY LPAREN OP_DCMP WITH
##
## Ends in an error in state: 40.
##
## dop_name -> LPAREN OP_DCMP . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DCMP
##

Missing ')'

prog: LCURLY LPAREN OP_DAPP WITH
##
## Ends in an error in state: 42.
##
## dop_name -> LPAREN OP_DAPP . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DAPP
##

Missing ')'

prog: LCURLY LPAREN OP_DADD WITH
##
## Ends in an error in state: 44.
##
## dop_name -> LPAREN OP_DADD . RPAREN [ WITH UNDERSCORE THEN STR SLASH SET SEMI RSQUARE RPAREN REF RCURLY OR OP_VRCN OP_VMUL OP_VCMP OP_VAPP OP_VADD OP_DRCN OP_DMUL OP_DCMP OP_DAPP OP_DADD NEG MATCH LSQUARE LPAREN LET LCURLY INT IF IDVAR IDCTOR ELSE COMMA COLON CHAR BAR ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN OP_DADD
##

Missing ')'

prog: LCURLY TYPE LCURLY IDCTOR SET BAR IDCTOR WITH
##
## Ends in an error in state: 46.
##
## ctor -> BAR IDCTOR . list(annot3) [ SEMI RCURLY BAR ]
##
## The known suffix of the stack is as follows:
## BAR IDCTOR
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR SET BAR IDCTOR IDCTOR WITH
##
## Ends in an error in state: 48.
##
## list(annot3) -> annot3 . list(annot3) [ SEMI RCURLY IMPLIES COMMA BAR ARROW ]
##
## The known suffix of the stack is as follows:
## annot3
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR SET BAR LPAREN OP_DADD RPAREN WITH
##
## Ends in an error in state: 50.
##
## ctor -> BAR dop_name . list(annot3) [ SEMI RCURLY BAR ]
##
## The known suffix of the stack is as follows:
## BAR dop_name
##

Incomplete type definition

prog: LCURLY TYPE LCURLY IDCTOR SET BAR IDCTOR IDVAR IMPLIES
##
## Ends in an error in state: 53.
##
## nonempty_list(ctor) -> ctor . [ SEMI RCURLY ]
## nonempty_list(ctor) -> ctor . nonempty_list(ctor) [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## ctor
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 48, spurious reduction of production list(annot3) ->
## In state 49, spurious reduction of production list(annot3) -> annot3 list(annot3)
## In state 47, spurious reduction of production ctor -> BAR IDCTOR list(annot3)
##

Incomplete type definition

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR IDVAR BAR
##
## Ends in an error in state: 163.
##
## cnsted_type -> IDCTOR list(annot3) . IMPLIES annot [ SEMI RCURLY ]
## cnsted_type -> IDCTOR list(annot3) . COMMA cnsted_type_tail [ SEMI RCURLY ]
## cnsted_type -> IDCTOR list(annot3) . ARROW annot [ SEMI RCURLY ]
## cnsted_type -> IDCTOR list(annot3) . [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 48, spurious reduction of production list(annot3) ->
## In state 49, spurious reduction of production list(annot3) -> annot3 list(annot3)
##

Incomplete type annotation

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR IMPLIES WITH
##
## Ends in an error in state: 164.
##
## cnsted_type -> IDCTOR list(annot3) IMPLIES . annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) IMPLIES
##

Missing constrainted type

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR COMMA WITH
##
## Ends in an error in state: 166.
##
## cnsted_type -> IDCTOR list(annot3) COMMA . cnsted_type_tail [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) COMMA
##

Missing another type constraint

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR COMMA IDCTOR WITH
##
## Ends in an error in state: 167.
##
## cnsted_type_tail -> IDCTOR . list(annot3) COMMA cnsted_type_tail [ SEMI RCURLY ]
## cnsted_type_tail -> IDCTOR . list(annot3) IMPLIES annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR
##

Incomplete type constraint

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR COMMA IDCTOR IDVAR SEMI
##
## Ends in an error in state: 168.
##
## cnsted_type_tail -> IDCTOR list(annot3) . COMMA cnsted_type_tail [ SEMI RCURLY ]
## cnsted_type_tail -> IDCTOR list(annot3) . IMPLIES annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 48, spurious reduction of production list(annot3) ->
## In state 49, spurious reduction of production list(annot3) -> annot3 list(annot3)
##

Incomplete type constraint

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR COMMA IDCTOR IMPLIES WITH
##
## Ends in an error in state: 169.
##
## cnsted_type_tail -> IDCTOR list(annot3) IMPLIES . annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) IMPLIES
##

Missing constrainted type

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR COMMA IDCTOR COMMA WITH
##
## Ends in an error in state: 171.
##
## cnsted_type_tail -> IDCTOR list(annot3) COMMA . cnsted_type_tail [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) COMMA
##

Missing another type constraint

prog: LCURLY DEF LCURLY IDVAR COLON IDCTOR ARROW WITH
##
## Ends in an error in state: 174.
##
## cnsted_type -> IDCTOR list(annot3) ARROW . annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) ARROW
##

Missing function return type

prog: LCURLY DEF LCURLY IDVAR COLON IDVAR ARROW WITH
##
## Ends in an error in state: 180.
##
## annot_no_ctor -> annot2_no_ctor ARROW . annot [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## annot2_no_ctor ARROW
##

Missing function return type

prog: LCURLY DEF LCURLY IDVAR COLON IDVAR AND
##
## Ends in an error in state: 269.
##
## vbinds -> vbind . SEMI vbinds [ RCURLY ]
## vbinds -> vbind . option(SEMI) [ RCURLY ]
##
## The known suffix of the stack is as follows:
## vbind
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 179, spurious reduction of production annot_no_ctor -> annot2_no_ctor
## In state 177, spurious reduction of production cnsted_type -> annot_no_ctor
## In state 176, spurious reduction of production vbind -> IDVAR COLON cnsted_type
##

Incomplete value definition

prog: LCURLY IMPL WITH
##
## Ends in an error in state: 311.
##
## toplevel -> IMPL . impl [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## IMPL
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR WITH
##
## Ends in an error in state: 312.
##
## impl -> IDCTOR . annot3 WITH block_vbinds [ SEMI RCURLY ]
## impl_cnsts -> IDCTOR . list(annot3) COMMA impl_cnsts [ IDCTOR ]
## impl_cnsts -> IDCTOR . list(annot3) IMPLIES [ IDCTOR ]
##
## The known suffix of the stack is as follows:
## IDCTOR
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR IDVAR IDVAR SEMI
##
## Ends in an error in state: 313.
##
## impl_cnsts -> IDCTOR list(annot3) . COMMA impl_cnsts [ IDCTOR ]
## impl_cnsts -> IDCTOR list(annot3) . IMPLIES [ IDCTOR ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 48, spurious reduction of production list(annot3) ->
## In state 49, spurious reduction of production list(annot3) -> annot3 list(annot3)
## In state 49, spurious reduction of production list(annot3) -> annot3 list(annot3)
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR COMMA WITH
##
## Ends in an error in state: 315.
##
## impl_cnsts -> IDCTOR list(annot3) COMMA . impl_cnsts [ IDCTOR ]
##
## The known suffix of the stack is as follows:
## IDCTOR list(annot3) COMMA
##

Missing another type constraint

prog: LCURLY IMPL IDCTOR COMMA IDCTOR WITH
##
## Ends in an error in state: 316.
##
## impl_cnsts -> IDCTOR . list(annot3) COMMA impl_cnsts [ IDCTOR ]
## impl_cnsts -> IDCTOR . list(annot3) IMPLIES [ IDCTOR ]
##
## The known suffix of the stack is as follows:
## IDCTOR
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR IDVAR TYPE
##
## Ends in an error in state: 318.
##
## impl -> IDCTOR annot3 . WITH block_vbinds [ SEMI RCURLY ]
## list(annot3) -> annot3 . list(annot3) [ IMPLIES COMMA ]
##
## The known suffix of the stack is as follows:
## IDCTOR annot3
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR IMPLIES WITH
##
## Ends in an error in state: 321.
##
## impl -> impl_cnsts . IDCTOR annot3 WITH block_vbinds [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## impl_cnsts
##

Incomplete trait implementation

prog: LCURLY IMPL IDCTOR IMPLIES IDCTOR WITH
##
## Ends in an error in state: 322.
##
## impl -> impl_cnsts IDCTOR . annot3 WITH block_vbinds [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## impl_cnsts IDCTOR
##

Missing implementing type

prog: LCURLY IMPL IDCTOR IMPLIES IDCTOR IDVAR UNDERSCORE
##
## Ends in an error in state: 323.
##
## impl -> impl_cnsts IDCTOR annot3 . WITH block_vbinds [ SEMI RCURLY ]
##
## The known suffix of the stack is as follows:
## impl_cnsts IDCTOR annot3
##

Incomplete trait implementation
